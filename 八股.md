# 1.MYSQL

#### 1.1 mysql的排序

mysql共有两种排序，一种是文件排序，一种是索引排序，当使用order by指令里面有索引的时候，则会使用索引进行排序，而如果没有，则会使用文件排序，文件排序基于一个缓存区，

当排序的数据大小小于这个缓存区的时候，进行的是**双路排序**，也就是基于**主键和当前排序字段**进行第一轮排序，排序完就回表进行第二轮

反之则是进行的单路排序，即通过将select的所以字段和排序字段一起放到缓存区一次查询返回

#### 1.2 changeBuffer 

changeBuffer的作用是用于对二级索引的修改进行缓存，因为修改一次二级索引需要花费很多时间，所以在修改索引的时候，并没有立即修改，而是先缓存起来，等到用的时候才真正修改

#### 1.3 一条sql的执行流程

1. 先通过权限校验校验数据库是否正确连接，以及权限校验
2. 然后通过分析器分析当前sql语句是否有语法错误
3. 然后通过优化器对主键等进行优化
4. 最后执行

#### 1.4 mysql有什么引擎

1. innodb，支持行级锁，事务，外键，支持高并发，支持聚簇索引



#### 1.5 索引类型

	1. 数据结构来看，B+树，倒排，哈希，R-
	1. B+数的 聚簇，非聚簇
	1. 普通（二级索引），主键索引，联合索引



#### 1.6 聚簇索引和非聚簇索引

innodb里面的主键索引就是聚簇索引，在他的叶子节点上面存在完整的数据信息，而其他节点则是只有页号



#### 1.7 回表

就是因为二级索引不存在直接结果，所以要根据二级索引对于的主键回表进行查询



#### 1.8 最左匹配原则

对于联合索引，只要有不等，或者跳过，则不满足除了（>=,<=,betwwen,like xx%)



#### 1.9 覆盖索引

就是说select的所要行在二级索引已经全部有了



#### 2.0 索引下推

对于联合索引 ，a,b,c会先根据这三个条件过滤数据，再直接返回



# 2. redis

#### 1.1  redis数据过期的删除策略

一个是定期删除，一个是数据满了之后删除，

删除会根据过期键的有无来区分

1.只删除过期

LRU，LFU，RADOM（随机

2.全部删除

LRU，LFU，RADOM（随机

TTL优先删除存活时间短的键

不删除，拒绝新写入

#### 1.2 LUA

lua脚本就是一个事务性的redis脚本，可以原子性的执行一串redis操作，但是不支持回滚

#### 1.3 pipeline

pipeline支持客户端一次性发送多条指令给redis执行，但是没有原子性，一条报错，其他还是会正常执行。

#### 1.4 bigkey问题

技术上

1.使用hash来代替String， hash即key，object，减少key的数量

2.对key进行切分

3.压缩存储对象的大小，使用更合适的编解码器，还可以减少网络IO的时间，当前用了messagePack去压缩

#### 1.5 热点key问题

1.前缀key

2.redis主从

3.cdn等redis前面再加缓存



# 3. netty

#### 1. 零拷贝

1. netty有fileRegion接口，可以直接调用操作系统的sendfile，直接从文件系统发送到网卡，而不需要经过jvm内存
2. 有内存映射文件，直接从内存映射内核



#### 2. netty的线程模型

netty使用的reactor线程模型，主要有

1.boss事务组，负责监听端口的连接，然后将连接交给workgroup去管理

2.workgroup，负责nio事件组进行读写等IO操作

3.业务线程组，进行简单的业务操作

#### 3. netty想比原生NIO的优势

1. 封装了NIO复杂的接口
2. 提供了优化的多线程模型，
3. 支持多种线程模型
4. 零拷贝



#### 4.

